# goit-algo-hw-04

| Sorting Algorithm         |   Random Smallest |   Random Small |   Random Big |   Random Largest |   Almost Sorted |   Reversed |
|---------------------------|-------------------|----------------|--------------|------------------|-----------------|------------|
| Insertion Sort            |           6e-06   |       0.000118 |     0.012263 |         1.29613  |        0.027059 |   1.31168  |
| Merge Sort                |           2.8e-05 |       9.7e-05  |     0.001034 |         0.013657 |        0.010725 |   0.013894 |
| Timsort (built-in sorted) |           3e-06   |       8e-06    |     9.4e-05  |         0.001087 |        0.000132 |   0.001056 |
| Bubble Sort               |           1.8e-05 |       0.000251 |     0.027674 |         3.00388  |        1.77616  |   2.99978  |
| Shell Sort                |           1.4e-05 |       6.5e-05  |     0.000963 |         0.017136 |        0.006678 |   0.01723  |
| Selection Sort            |           5e-06   |       0.000122 |     0.013329 |         1.35362  |        1.41906  |   1.35589  |

Сортування вставками демонструє хорошу продуктивність на малих наборах даних. Однак, час виконання значно збільшується з ростом розміру даних. Особливо видно, що на великих масивах даних алгоритм працює значно довше (O(n^2)). На майже відсортованих наборах даних працює досить ефективно.

Сортування злиттям показує стабільну продуктивність на всіх наборах даних. Алгоритм має часову складність O(n log n) і демонструє стабільні результати як на випадкових, так і на майже відсортованих і реверсивних наборах даних. Це робить його хорошим вибором для великих масивів даних.

Timsort є найбільш ефективним алгоритмом для більшості випадків. Він демонструє найменші часи виконання серед усіх тестів. Його ефективність на майже відсортованих наборах даних особливо висока, що підтверджує його переваги перед іншими алгоритмами. Це робить його найкращим вибором для використання у вбудованих функціях Python.

Сортування бульбашкою показує значно гірші результати, ніж інші алгоритми. Час виконання суттєво збільшується зі збільшенням розміру даних, що робить цей алгоритм непридатним для використання з великими масивами даних. Він має часову складність O(n^2) і виявляється повільнішим навіть на невеликих наборах даних.

Сортування Шелла показує досить ефективні результати на всіх наборах даних. Хоча його продуктивність дещо поступається Timsort, він значно перевершує сортування вставками і бульбашкою. Алгоритм підходить для середніх і великих масивів даних.

Сортування вибором демонструє продуктивність, аналогічну сортуванню вставками, із значним збільшенням часу виконання на великих масивах даних. Цей алгоритм також має часову складність O(n^2) і виявляється менш ефективним на великих наборах даних.

Timsort (вбудована функція sorted в Python) є найефективнішим серед протестованих алгоритмів сортування. Його продуктивність особливо помітна на великих масивах даних і майже відсортованих наборах, що робить його найкращим вибором для більшості випадків використання. Merge Sort також демонструє стабільні результати і є хорошим вибором для великих масивів даних. Інші алгоритми, такі як Insertion Sort, Bubble Sort, Shell Sort і Selection Sort, показують значно гірші результати, особливо на великих наборах даних, і менш придатні для використання в практичних завданнях.